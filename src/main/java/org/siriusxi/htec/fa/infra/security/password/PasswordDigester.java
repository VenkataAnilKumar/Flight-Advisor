package org.siriusxi.htec.fa.infra.security.password;

import org.springframework.stereotype.Component;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;

import static java.lang.System.arraycopy;
import static java.util.Arrays.copyOfRange;
import static java.util.Base64.getDecoder;
import static java.util.Base64.getEncoder;
import static java.util.Objects.isNull;

/**
 * Component allowing to salt, hash and base64-encode passwords, as well as match passwords against
 * encoded passwords.
 *
 * @author Venkata Anil Kumar
 */
@Component
public class PasswordDigester {
    
    /**
     * Generates a salt, hashes the password with this salt, concatenates the salt and the hash, and
     * encodes the result using Base64.
     */
    public String hash(String password) {
        var salt = Salt.generateSalt();
        var digest = Salt.hash(password, salt);
        var concatenation = concat(salt, digest);
        return getEncoder().encodeToString(concatenation);
    }
    
    /**
     * Concat two byte arrays into one
     *
     * @param first  - the first array
     * @param second - the second array
     * @return a concatenated array
     */
    private byte[] concat(byte[] first, byte[] second) {
        var concatenation = new byte[first.length + second.length];
        arraycopy(first, 0, concatenation, 0, first.length);
        arraycopy(second, 0, concatenation, first.length, second.length);
        return concatenation;
    }
    
    /**
     * Verifies a password against a hashed password generated by [.hash]
     */
    public boolean match(String password, String hashedPassword) {
        if (isNull(hashedPassword) || hashedPassword.isBlank())
            return false;
        
        var concatenation = getDecoder().decode(hashedPassword);
        var salt = copyOfRange(concatenation, 0, Salt.SALT_LENGTH);
        var digest = copyOfRange(concatenation, Salt.SALT_LENGTH, concatenation.length);
        var newDigest = Salt.hash(password, salt);
        return Arrays.equals(newDigest, digest);
    }
    
    private static final class Salt {
        private static final int SALT_LENGTH = 8;
        private static final int ITERATION_COUNT = 4096;
        private static final int KEY_LENGTH = 256;
        
        private static byte[] generateSalt() {
            try {
                var salt = new byte[SALT_LENGTH];
                SecureRandom.getInstance("SHA1PRNG").nextBytes(salt);
                return salt;
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException(e);
            }
        }
        
        private static byte[] hash(String password, byte[] salt) {
            try {
                var factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
                var keySpec = new PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, KEY_LENGTH);
                var secretKey = factory.generateSecret(keySpec);
                return secretKey.getEncoded();
            } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
                throw new IllegalStateException(e);
            }
        }
    }
}
